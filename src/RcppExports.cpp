// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include <Rcpp.h>

using namespace Rcpp;

#ifdef RCPP_USE_GLOBAL_ROSTREAM
Rcpp::Rostream<true>&  Rcpp::Rcout = Rcpp::Rcpp_cout_get();
Rcpp::Rostream<false>& Rcpp::Rcerr = Rcpp::Rcpp_cerr_get();
#endif

// createBoolean
Eigen::Array<bool, Eigen::Dynamic, 1> createBoolean(Eigen::VectorXd v);
RcppExport SEXP _marginal_createBoolean(SEXP vSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type v(vSEXP);
    rcpp_result_gen = Rcpp::wrap(createBoolean(v));
    return rcpp_result_gen;
END_RCPP
}
// createBoolean2
Eigen::Array<bool, Eigen::Dynamic, 1> createBoolean2(Eigen::VectorXd v);
RcppExport SEXP _marginal_createBoolean2(SEXP vSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type v(vSEXP);
    rcpp_result_gen = Rcpp::wrap(createBoolean2(v));
    return rcpp_result_gen;
END_RCPP
}
// logicalAnd
Eigen::Array<bool, Eigen::Dynamic, 1> logicalAnd(Eigen::Array<bool, Eigen::Dynamic, 1> vec1, Eigen::Array<bool, Eigen::Dynamic, 1> vec2);
RcppExport SEXP _marginal_logicalAnd(SEXP vec1SEXP, SEXP vec2SEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< Eigen::Array<bool, Eigen::Dynamic, 1> >::type vec1(vec1SEXP);
    Rcpp::traits::input_parameter< Eigen::Array<bool, Eigen::Dynamic, 1> >::type vec2(vec2SEXP);
    rcpp_result_gen = Rcpp::wrap(logicalAnd(vec1, vec2));
    return rcpp_result_gen;
END_RCPP
}
// SubsetVector
Eigen::VectorXd SubsetVector(Eigen::VectorXd v, Eigen::Array<bool, Eigen::Dynamic, 1> boolVec);
RcppExport SEXP _marginal_SubsetVector(SEXP vSEXP, SEXP boolVecSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type v(vSEXP);
    Rcpp::traits::input_parameter< Eigen::Array<bool, Eigen::Dynamic, 1> >::type boolVec(boolVecSEXP);
    rcpp_result_gen = Rcpp::wrap(SubsetVector(v, boolVec));
    return rcpp_result_gen;
END_RCPP
}
// sumVector
double sumVector(Eigen::VectorXd v);
RcppExport SEXP _marginal_sumVector(SEXP vSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type v(vSEXP);
    rcpp_result_gen = Rcpp::wrap(sumVector(v));
    return rcpp_result_gen;
END_RCPP
}
// vcols
Eigen::VectorXd vcols(Eigen::MatrixXd vab, int idx);
RcppExport SEXP _marginal_vcols(SEXP vabSEXP, SEXP idxSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< Eigen::MatrixXd >::type vab(vabSEXP);
    Rcpp::traits::input_parameter< int >::type idx(idxSEXP);
    rcpp_result_gen = Rcpp::wrap(vcols(vab, idx));
    return rcpp_result_gen;
END_RCPP
}
// elementWiseMultiplication
Eigen::ArrayXd elementWiseMultiplication(const Eigen::ArrayXd& array1, const Eigen::ArrayXd& array2);
RcppExport SEXP _marginal_elementWiseMultiplication(SEXP array1SEXP, SEXP array2SEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Eigen::ArrayXd& >::type array1(array1SEXP);
    Rcpp::traits::input_parameter< const Eigen::ArrayXd& >::type array2(array2SEXP);
    rcpp_result_gen = Rcpp::wrap(elementWiseMultiplication(array1, array2));
    return rcpp_result_gen;
END_RCPP
}
// elementWiseMultiply
NumericVector elementWiseMultiply(NumericVector x, NumericVector y);
RcppExport SEXP _marginal_elementWiseMultiply(SEXP xSEXP, SEXP ySEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< NumericVector >::type x(xSEXP);
    Rcpp::traits::input_parameter< NumericVector >::type y(ySEXP);
    rcpp_result_gen = Rcpp::wrap(elementWiseMultiply(x, y));
    return rcpp_result_gen;
END_RCPP
}
// Update_Eigen
Eigen::VectorXd Update_Eigen(Eigen::MatrixXd vab, Eigen::VectorXd gab, Eigen::VectorXd gabt, int n);
RcppExport SEXP _marginal_Update_Eigen(SEXP vabSEXP, SEXP gabSEXP, SEXP gabtSEXP, SEXP nSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< Eigen::MatrixXd >::type vab(vabSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type gab(gabSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type gabt(gabtSEXP);
    Rcpp::traits::input_parameter< int >::type n(nSEXP);
    rcpp_result_gen = Rcpp::wrap(Update_Eigen(vab, gab, gabt, n));
    return rcpp_result_gen;
END_RCPP
}

static const R_CallMethodDef CallEntries[] = {
    {"_marginal_createBoolean", (DL_FUNC) &_marginal_createBoolean, 1},
    {"_marginal_createBoolean2", (DL_FUNC) &_marginal_createBoolean2, 1},
    {"_marginal_logicalAnd", (DL_FUNC) &_marginal_logicalAnd, 2},
    {"_marginal_SubsetVector", (DL_FUNC) &_marginal_SubsetVector, 2},
    {"_marginal_sumVector", (DL_FUNC) &_marginal_sumVector, 1},
    {"_marginal_vcols", (DL_FUNC) &_marginal_vcols, 2},
    {"_marginal_elementWiseMultiplication", (DL_FUNC) &_marginal_elementWiseMultiplication, 2},
    {"_marginal_elementWiseMultiply", (DL_FUNC) &_marginal_elementWiseMultiply, 2},
    {"_marginal_Update_Eigen", (DL_FUNC) &_marginal_Update_Eigen, 4},
    {NULL, NULL, 0}
};

RcppExport void R_init_marginal(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
